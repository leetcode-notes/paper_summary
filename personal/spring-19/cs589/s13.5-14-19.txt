Modular Object-Oriented Programming with Units and Mixins,
R. B. Findler and M Flatt

Notes:


--------------------------------------------------------------
In-calss assignment:

Summary notes:
Summary:
The paper discusses the interaction between modules (units) and 
classes (mixins) and how one can improve software reuse by considering
this interaction as well as separating this connection from their
definitions. They achieve this by first defining units and mixins with
explicit imports and exports (without compiling the code) and then 
linking them in the final program. In order to solve the extensibility
problem they keep all old original code and add new variants with 
extensions to it.

Take home(s):
- Modules and classes offer different advantages for code reuse and 
  considering both helps improve code reuse immensly which relies 
  heavily on separating the definition of them from their connections.

Questions/topics for discussion:
- What is a formal definition of a client? To me it seems that they 
  consider a piece of code client of another piece of code if it refers
  to it. Is that right?
- To me it seems that they keep the original code and just repeat it 
  according to the extensions made and call it the solution to the
  extensibility problem. Isn't this just having repeatitive similar
  code all over the place? Although, in their approach this repeteation 
  is only done for linking programs, which is probably much less 
  repeteation compared to other approaches.
- So they're approach works only for dynamically typed languages?
- How would one put the following lesson in terms of Haskell: "Separate a 
  module's linking specification from its encapsulated definitions."


Discussion notes:
Summary:
The paper proposes a language with built-in support for extensibility
in both dimensions by introducing units (similar to Java packages except
that they're linked externally) and mixins (similar to Java classes 
except that they're parametrized over their superclass and can be applied
multiple times) and separating the definitions of these components from 
their linking. 

Take home(s):
- Defining signatures separately from implementation gives us a better
  upportunity for extensibility, no matter what language we're using.
  
Discussion highlights:
- While the extensibility is built into their language (MzScheme), other
  languages like Java provide us the tools to allow for such extensibility
  however we need to apply some techniques like the visitor pattern in 
  order to achieve it.
- We can think of Haskell module system as a conventional module system and
  Java's classes (without interfaces) as conventional classes.
- By loosening the restrictions of conventional classes and modules we can
  solve the extensibility problem rather elegantly.
- Mixins are similar to ML functors.
- We can think of both lessons they're talking about in terms of Haskell's 
  type classes.
- If we add type signatures to units it could also work for statically typed
  languages.
