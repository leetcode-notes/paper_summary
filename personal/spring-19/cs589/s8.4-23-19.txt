Harper and Pierce, Design Considerations for an ML-Style Module System, 
from Advanced Topics in Types and Programming Languages, 2005 
Sections 8.1â€“8.4

Notes:
- module: parts of manageable size when breaking down a large prog.
- module (structure): a collection of components which may include procedure
  or function definitions, variable declarations, type definitions, and
  initialization code.
- methodology of modularity: how best to decompose progs into modules with
  a variety of desiarable engineering characteristics.
- abstract types arise by sealing a module with a signature that selectively
  suppresses the definitions of its type components. 
- root module: the main entry point of the prog.
- linker task: compose a complete prog by resolving external references,
  creating module bindings for each of the external references in the partial
  prog under construction until no unresolved references remain.
- signature (interface): describes the externally visible components of the 
  module that is some other module is depending on.
- a prog consists of bindings, each of which is either a module binding or a
  signature binding.
- module binding: binds the variable to a modue expression, perhaps with a 
  specified signature.
- basic signature: consists of a sequence of component declarations, either a 
  type decl or a value decl.
- prinicipal signature: the most precise signature implemented by a module.
- 

--------------------------------------------------------------------
In-calss assignment:

Summary notes:
Summary:
The chapter so far discussed mechanism of supporting modular programming.
based on a typing system for modularity grounded in the framework of TAPL.
It introduces lots of terminologies such as module, root module, 
signature, external reference, external and internal name, basic signature,
principal signature, signature matching (and its two styles: structural 
and nominal), two methods
of compilation: separate and incremental, cut-off compilation, linker, 
linking context, resolving external references, reference dependencies, 
initialization dependencies, definite and indifinite external reference,
phase distinction, firts- and second-class modules.

Take home(s):
The overal take home of the chapter for me was the need to have
a type system for the modularity system of a language and that we can 
implement a modularity system for a language based on different factors, 
some features of the language dictate some features of the modularity 
system (eg.: whether we have first- or second-class modules depends on the
language being statically typed or what they define as dependent typed 
language), while for some other features of the modularity system we can
decide based on the criteria we're looking for the system (eg.: whether 
we choose separate compilation or incremental). And of course, there are
some features that are just shared among all modularity systems (eg.:the 
order of bindings of modules depends both on reference dependencies and 
initialization dependencies).

Questions/topics for discussion:
- What compilation system is GHC (separate or incremental)? (My thought: separate)
- "A module system that lacks prinicipal signatures cannot properly
  support incremental compilation." Is this because we can reduce the problem
  of checking whether a module implements a signature to checking the subtype 
  relation between the given signature and the module's principle signature and
  in incremental compilation the compiler consults the implementation of a 
  module to determine its signature and so if we cannot reduce the problem then
  it's undecidable?!!
- What's the relationship between statically typed languages, dynamically 
  typed languages and dependet typed languages with respecting or violating
  the phase distinction? (They're definition of dependent typed languages 
  seems to be different from my understanding!!)


Discussion notes:
Summary:

Take home(s):

Discussion highlights:
